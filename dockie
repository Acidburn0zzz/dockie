#!/usr/bin/env sh
# BSD 3-Clause License
# 
# Copyright (c) 2020, Cristian Ariza
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -eu

_bootstrap_error() {
	rm -rf "$2"
	_log_fatal "Error response: pull access denied for $1"
}

_bootstrap_hash() {
	hash="$(echo "$*$(_date)" | sha1sum)"

	# the only way I found to cut characters in POSIX using only builtins
	echo "${hash%???????????????????????????????}"
}

_bootstrap_config() {
	guest_path="$2"
	guest_name="$(_strings_basename "$guest_path")"
	guest_prefix="$guest_path/rootfs"

	id="$(_bootstrap_hash "$*")"

	echo "$id,$guest_name,$(_date),$1" > "$guest_path/info"

	{
		echo 
		echo "# added by dockie"
		echo "export PS1='\033[30;34m\u@$guest_name \w \\$ \033[30;39m'"
		echo "export DISPLAY='$DISPLAY'" 
	} >> "$guest_prefix/etc/profile"

	cp /etc/resolv.conf "$guest_prefix/etc/resolv.conf"

	echo "$id"
}

_bootstrap() {
	system="$1"
	guest_path="$2"
	guest_prefix="$guest_path/rootfs"

	[ ! -d "$DOCKIE_IMAGES/$system" ] && _pull "$system"

	mkdir -p "$guest_prefix"
	cd "$guest_prefix" || exit 1
	# sometimes tar has errors and this is ok
	sh "$DOCKIE_IMAGES/$system/bootstrap" || true

	_bootstrap_config "$@"
}
_date(){
	date '+%Y-%m-%d %H:%M:%S'
}
# Usage: dockie exec [OPTIONS] ROOTFS COMMAND [ARG...]
#
# Run a command in an existing rootfs
#
# Options:
# 	--gui      Use when a GUI is going to be run
# 	--install  Use when packages need to be installed
# 	--user     Specify Username
#
_exec_get_uid() {
	passwd="$DOCKIE_GUESTS/$2/rootfs/etc/passwd"

	[ ! -f "$passwd" ] && _log_fatal "/etc/passwd not found on rootfs"

	awk -F ':' "\$1 == \"$1\" { print \$3 }" "$passwd"
}

_exec_is_opt() {
	case x"$1" in
	x-*) return 0 ;;
	*) return 1 ;;
	esac
}

_exec() {
	[ "$#" -lt 2 ] && _print_usage "exec"

	type="-r"
	user=
	flags="-w /"

	c="$1"
	shift
	while _exec_is_opt "$c"; do
		case x"$c" in
		x--gui | x-g) flags="$flags -b /proc -b /dev" ;;
		x--user | x-u) user="$1" && shift ;;
		x--install | x-i) type='-S' ;;
		esac

		c="$1"
		shift
	done

	guest_name="$c"

	[ ! -d "$DOCKIE_GUESTS/$guest_name" ] &&
		_log_fatal "Error: No such guest: $guest_name"

	[ "$#" -eq 0 ] && _print_usage exec

	[ -z "$user" ] && flags="$flags -0" ||
		flags="$flags -i $(_exec_get_uid "$user" "$guest_name")"

	echo
	echo "$(_strings_basename "$0"): to get the proper prompt, always " \
		"run sh/bash with the '-l' option"
	echo

	PROOT="$(which proot)"

	# shellcheck disable=SC2086
	env -i "$PROOT" $flags "$type" "$DOCKIE_GUESTS/$guest_name/rootfs" "$@"
}
# Usage: dockie image COMMAND
#
# Manage images
#
# Commands:
#   ls    List images
#   pull  Pull an image
#   rm    Remove one or more images" >&2
#
#
_image() {
	[ "$#" -eq 0 ] && ls -1 "$DOCKIE_IMAGES" && exit 0

	cmd="$1" && shift

	_image_"$cmd" "$@" || _print_usage "image"
}

_images() {
	_image "$@"
}

# Usage: dockie image rm [OPTIONS] ROOTFS [ROOTFS...]
#
# Remove one or more rootfs'.
#
_image_rm() {
	[ "$#" -eq 0 ] && _print_usage "image rm"

	# just to make sure we don't delete what we shouldn't
	cd "$DOCKIE_IMAGES" || exit 1

	for fs; do
		[ ! -d "$DOCKIE_IMAGES/$fs" ] &&
			_log_fatal "Error: No such container: $fs"
		rm -rf ./"$fs" && echo "$fs"
	done
}
_log_fatal() {
	echo "$(_strings_basename "$0"): $*"
	exit 1
}
# Usage: dockie ls
#
# List rootfs
#
_ls() {
	[ "$#" -ne 0 ] && _print_usage "ls"

	# posix built-in way of checking if directory is empty, might fail if
	# there is a single file called '*' but you should probably not do that
	{
		echo "ROOTFS ID,IMAGE,CREATED,NAME"
		cat "$DOCKIE_GUESTS"/*/info 2>/dev/null
	} | awk -F ',' '{printf "%-15s%-15s%-25s%s\n",$1,$2,$3,$4}'
}

_ps() {
	_ls "$@"
}
# Usage: dockie pull [OPTIONS] NAME
#
# Pull an image or a repository from a registry' >&2
#

_pull_error() {
	rm -rf "${DOCKIE_IMAGES:?}/$system"
	_log_fatal "pull failed for $system"
}

_pull() {
	[ "$#" -ne 1 ] && _print_usage "pull"

	system="$1"

	bootstrap="$REMOTE/$system/bootstrap"

	rm -rf "${DOCKIE_IMAGES:?}/$system"
	mkdir -p "$DOCKIE_IMAGES/$system"

	echo "Pulling from dockie-hub/$system"

	# shellcheck disable=SC2015
	tar_url="$(wget -q -O- "$REMOTE/$system/url" | sh)" &&
		wget "$tar_url" -P "$DOCKIE_IMAGES/$system" &&
		wget -q "$bootstrap" -P "$DOCKIE_IMAGES/$system" ||
		_pull_error

	echo "Downloaded rootfs for $system"
}
# Usage: dockie rm [OPTIONS] ROOTFS [ROOTFS...]
#
# Remove one or more rootfs.
#
_rm() {
	[ "$#" -eq 0 ] && _print_usage rm

	cd "$DOCKIE_GUESTS" || exit 1

	for fs; do
		[ ! -d "$DOCKIE_GUESTS/$fs" ] &&
			_log_fatal "Error: No such container: $fs"
		chmod -R +w "$fs" && rm -r "$fs" && echo "$fs"
	done
}
# Usage: dockie run [OPTIONS] SYSTEM [COMMAND] [ARG...]
#
# Run a command in a new rootfs
#
# Options:
#     --name string    Assign a name to the container'
#

_run_error_existing() {
	_log_fatal "dockie: The container name '$1' is already in use."
}

_run() {
	[ "$#" -eq 0 ] && _print_usage "run"

	echo Bootstraping... This may take a few minutes.

	[ "$1" = "--name" ] && shift && guest_name="$1" && shift

	system_name="$1" && shift

	# need a guest name if the user did not specify any
	: "${guest_name=$system_name}"

	[ -d "$DOCKIE_GUESTS/$guest_name" ] &&
		_run_error_existing "$guest_name"

	mkdir -p "$DOCKIE_GUESTS/$guest_name/rootfs"

	_bootstrap "$system_name" "$DOCKIE_GUESTS/$guest_name"

	[ "$#" -ne 0 ] && _exec "$guest_name" "$@"
}
_strings_basename() {
	dir=${1%${1##*[!/]}}
	dir=${dir##*/}
	printf '%s\n' "${dir:-/}"
}
# Usage: dockie [OPTIONS] COMMAND [ARG...]
#
# Dockie is a wrapper around PRoot with a familiar interface
#
# Options:
# 	-d        Debug mode
# 	-h        Print usage
# 	-v        Print version information and quit
#
# Commands:
# 	exec      Run a command in a root filesystem
# 	image     List images
# 	ls        List root filesystems
# 	pull      Pull an image
# 	rm        Remove one or more root filesystems
# 	run       Run a command in a new root filesystem
#
# Run 'dockie COMMAND' for more information on a command.
#

VERSION="v0.3.0"

PREFIX="$HOME/.local"

# need to export for bootstrap scripts
export DOCKIE_IMAGES="$PREFIX/var/lib/dockie/images"
mkdir -p "$DOCKIE_IMAGES"

# need to export for bootstrap scripts
export DOCKIE_GUESTS="$PREFIX/var/lib/dockie/guests"
mkdir -p "$DOCKIE_GUESTS"

REMOTE="https://raw.githubusercontent.com/cristianrz/dockie-hub/master"

_print_usage() {
	# grab usages from comments
	awk '
	/^# Usage: dockie '"$1"'/, $0 !~ /^#/ {
		if ( $0 ~ /^#/ ) {
			gsub(/# ?/,"")
			print
		}
	}
	' "$0"
	exit 1
}

[ "$#" -eq 0 ] && _print_usage "\[O"
[ "$1" = "-v" ] && echo "Dockie version $VERSION" && exit 0
[ "$1" = "-d" ] && set -x && shift

cmd="_$1" && shift

"$cmd" "$@" || _print_usage "\[O"
